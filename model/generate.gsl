.#  Generate C++ source and make files for SX
.#
.#  This is a code generator built using the iMatix GSL code generation
.#  language. See https://github.com/imatix/gsl for details.
.#
.#  This file contains no localizable resources.
.#
.##############################################################################
.# This section is a GSL define/macro/function library.
.
.macro global.copyleft
/**
 * Copyright (c) 2011-2014 sx developers (see AUTHORS)
 *
 * This file is part of sx.
 *
 * sx is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License with
 * additional permissions to the one published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version. For more information see LICENSE.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
.endmacro
.
.function global.default_type(is_option, type)
.   bool_default = my.is_option & is_empty(my.type)
.   return normalize_type(if_else(bool_default, type_bool, my.type ? \
        type_string))
.endfunction
.
.function global.first_char(value)
.   return string.substr(my.value, 0, 0)
.endfunction
.
.function global.if_else(antecedent, consequent, alternate)
.   return my.antecedent ?? my.consequent ? my.alternate
.endfunction
.
.function global.if_else_empty(antecedent, consequent)
.   return if_else(my.antecedent, my.consequent, "")
.endfunction
.
.function global.is_default(value, fallback)
.   return conv.number(my.value ? my.fallback) = my.fallback
.endfunction
.
.function global.is_empty(value)
.   return ((my.value ? "") = "")
.endfunction
.
.function global.is_xml_true(value)
.   return ((my.value ? xml_false) = xml_true)
.endfunction
.
.function global.last_char(value)
.   position = string.length(my.value)
.   character = string.substr(my.value, position, position)
.   return character
.endfunction
.
.# TODO: hash table
.function global.normalize_type(type)
.   if my.type = type_address
.       return type_address_sx
.   elsif my.type = type_base16
.       return type_base16_sx
.   elsif my.type = type_base58
.       return type_base58_sx
.   elsif my.type = type_btc
.       return type_btc_sx
.   elsif my.type = type_btc160
.       return type_btc160_sx
.   elsif my.type = type_btc256
.       return type_btc256_sx
.   elsif my.type = type_ec_private
.       return type_ec_private_sx
.   elsif my.type = type_ec_public
.       return type_ec_public_sx
.   elsif my.type = type_encoding
.       return type_encoding_sx
.   elsif my.type = type_file
.       return type_file_sx
.   elsif my.type = type_hashtype
.       return type_hashtype_sx
.   elsif my.type = type_hd_key
.       return type_hd_key_sx
.   elsif my.type = type_hd_private
.       return type_hd_private_sx
.   elsif my.type = type_hd_public
.       return type_hd_public_sx
.   elsif my.type = type_header
.       return type_header_sx
.   elsif my.type = type_input
.       return type_input_sx
.   elsif my.type = type_output
.       return type_output_sx
.   elsif my.type = type_path
.       return type_path_boost
.   elsif my.type = type_point
.       return type_point_sx
.   elsif my.type = type_prefix
.       return type_prefix_sx
.   elsif my.type = type_raw
.       return type_raw_sx
.   elsif my.type = type_script
.       return type_script_sx
.   elsif my.type = type_stealth
.       return type_stealth_sx
.   elsif my.type = type_string
.       return type_string_std
.   elsif my.type = type_transaction
.       return type_transaction_sx
.   elsif my.type = type_wif
.       return type_wif_sx
.   elsif my.type = type_wrapper
.       return type_wrapper_sx
.   endif
.   return my.type
.endfunction
.
.function global.pluralize(name, is_plural)
.   if (my.is_plural)
.#BUGBUG: the string comparison just doesn't work.
.       return my.name + if_else_empty(last_char(my.name) = "s", "e") + "s"
.   endif
.   return my.name
.endfunction
.
.function global.pretty(text, format)
.   return "$(my.text:$(my.format))"
.endfunction
.
.function global.quote(text, is_quoted)
.   return if_else(my.is_quoted, "\"$(my.text:)\"", my.text)
.endfunction
.
.function global.resource(name, fallback)
.   for resource
.       for resource.string
.           if (name ? "") = my.name
.               return value ? ""
.           endif
.       endfor
.   endfor
.   return my.fallback ? ""
.endfunction
.
.function global.true()
.   return 0 = 0
.endfunction
.
.function global.value_semantic(is_file, is_option, type, required,\
    unlimited, variable, fallback)
.
.   def_type = default_type(my.is_option, my.type)
.   norm_type = if_else(my.is_file, type_string_std, def_type)
.   implicit_bool = my.is_option & (norm_type = type_bool)
.   defaulted = !is_empty(my.fallback)
.   is_text = ((norm_type = type_path_boost) | (norm_type = type_string_std))
.   quote_default = (defaulted & is_text)
.
.   norm_unlimited = my.unlimited & !my.is_file
.   parameter = if_else_empty(!is_empty(my.variable), "&$(my.variable:)")
.   binding = if_else(my.is_file, "", pluralize(parameter, norm_unlimited))
.   default_value = quote(if_else_empty(defaulted, my.fallback), quote_default)
.
.   expr = "value<$(vectored_type(norm_type, norm_unlimited))>($(binding:))"
.   expr += if_else_empty(my.required, "->required()")
.   expr += if_else_empty(defaulted, "->default_value($(default_value:))")
.   expr += if_else_empty(implicit_bool, "->implicit_value(true)")
.   return expr
.
.endfunction
.
.function global.vectored_type(type, is_vector)
.   return if_else(my.is_vector, "std::vector<$(my.type:)>", my.type)
.endfunction
.
.config_description = resource("sx_config_description")
.config_option = "config"
.type_bool = "bool"
.type_address = "address"
.type_base16 = "base16"
.type_base58 = "base58"
.type_btc = "btc"
.type_btc160 = "btc160"
.type_btc256 = "btc256"
.type_ec_private = "ec_private"
.type_ec_public = "ec_public"
.type_encoding = "encoding"
.type_file = "file"
.type_hashtype = "hashtype"
.type_hd_key = "hd_key"
.type_hd_private = "hd_private"
.type_hd_public = "hd_public"
.type_header = "header"
.type_input = "input"
.type_output = "output"
.type_point = "point"
.type_path = "path"
.type_prefix = "prefix"
.type_raw = "raw"
.type_script = "script"
.type_stealth = "stealth"
.type_string = "string"
.type_transaction = "transaction"
.type_wif = "wif"
.type_wrapper = "wrapper"
.
.type_address_sx = "serializer::address"
.type_base16_sx = "serializer::base16"
.type_base58_sx = "serializer::base58"
.type_btc_sx = "serializer::btc"
.type_btc160_sx = "serializer::btc160"
.type_btc256_sx = "serializer::btc256"
.type_ec_private_sx = "serializer::ec_private"
.type_ec_public_sx = "serializer::ec_public"
.type_encoding_sx = "serializer::encoding"
.type_file_sx = "serializer::file"
.type_hashtype_sx = "serializer::hashtype"
.type_hd_key_sx = "serializer::hd_key"
.type_hd_private_sx = "serializer::hd_priv"
.type_hd_public_sx = "serializer::hd_pub"
.type_header_sx = "serializer::header"
.type_input_sx = "serializer::input"
.type_output_sx = "serializer::output"
.type_path_boost = "boost::filesystem::path"
.type_point_sx = "serializer::point"
.type_prefix_sx = "serializer::prefix"
.type_raw_sx = "serializer::raw"
.type_script_sx = "serializer::script"
.type_stealth_sx = "serializer::stealth"
.type_string_std = "std::string"
.type_transaction_sx = "serializer::transaction"
.type_wif_sx = "serializer::wif"
.type_wrapper_sx = "serializer::wrapper"
.
.xml_false = "false"
.xml_true = "true"
.
.##############################################################################
.echo "Generating include/sx/generated.hpp..."
.output "../include/sx/generated.hpp"
.copyleft()
#ifndef SX_GENERATED_HPP
#define SX_GENERATED_HPP

#include <functional>
#include <memory>
#include <string>
#include <sx/command.hpp>
.for command by symbol
#include <sx/command/$(symbol).hpp>
.endfor

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

#define SX_VARIABLE_CONFIG "$(config_option:)"

namespace sx {

/**
 * Invoke a specified function on all commands.
 * @param[in]  func  The function to invoke on all commands.
 * @return           True if invoked successfully.
 */
bool broadcast(const std::function<void(std::shared_ptr<command>)> func);

/**
 * Find the command identified by the specified symbolic command name.
 * @param[in]  symbol  The symbolic command name.
 * @return             An instance of the command or nullptr if not found.
 */
std::shared_ptr<command> find(const std::string& symbol);

} // sx

#endif
.##############################################################################
.echo "Generating src/generated.cpp..."
.output "../src/generated.cpp"
.copyleft()
#include "precompile.hpp"
#include <sx/generated.hpp>

#include <functional>
#include <memory>
#include <string>
#include <vector>
#include <sx/command.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

using namespace po;
using namespace std;
using namespace boost::filesystem;
    
namespace sx {
using namespace extension;

bool broadcast(const function<void(shared_ptr<command>)> func)
{
.for command by symbol
    func(make_shared<$(symbol:c)>());
.endfor

    return true;
}

shared_ptr<command> find(const string& symbol)
{
.for command by symbol
    if (symbol == $(symbol:c)::symbol())
        return make_shared<$(symbol:c)>();
.endfor

    return nullptr;
}

} // sx
.##############################################################################
.echo "Generating include/sx/command.hpp..."
.output "../include/sx/command.hpp"
.copyleft()
#ifndef SX_COMMAND_HPP
#define SX_COMMAND_HPP

#include <iostream>
#include <string>
#include <vector>
#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>
#include <sx/define.hpp>
#include <sx/utility/config.hpp>
#include <sx/utility/utility.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

namespace sx {

#define SX_VARIABLE_CONFIG "config"

/**
 * Abstract base class for definition of each SX command.
 */
class command
{
public:
    
    /**
     * The symbolic (not localizable) command name, lower case.
     */
    static const char* symbol() { return "not-implemented"; }

    /**
     * The symbolic (not localizable) command name, lower case.
     * @return  Example: "fetch-transaction"
     */
    virtual const char* name()
    {
        return symbol();
    }

    /**
     * The localizable command category name, upper case.
     * @return  Example: "ONLINE"
     */
    virtual const char* category()
    {
        return symbol();
    }
    
    /**
     * Invoke the command.
     * @param[out]  output  The input stream for the command execution.
     * @param[out]  error   The input stream for the command execution.
     * @return              The appropriate console return code { -1, 0, 1 }.
     */
    virtual console_result invoke(std::ostream& output, std::ostream& error)
    {
        return console_result::failure;
    }

    /**
     * Load command argument definitions.
     * A value of -1 indicates that the number of instances is unlimited.
     * @return  The loaded argument definitions.
     */
    virtual po::positional_options_description& load_arguments()
    {
        return argument_metadata_;
    }

    /**
     * Load environment variable definitions.
     * @param[out] definitions  The defined program argument definitions.
     */
    virtual void load_environment(po::options_description& definitions)
    {
        using namespace po;
        definitions.add_options()
            /* This composes with the command line options. */
            (
                SX_VARIABLE_CONFIG, 
                value<boost::filesystem::path>()
                    ->composing()->default_value(config_default()),
                "$(config_description:)"
            );
    }
    
    /**
     * Load parameter fallbacks from file or input as appropriate.
     * @param[in]  input      The input stream for loading the parameters.
     * @param[in]  variables  The loaded variables.
     */
    virtual void load_fallbacks(std::istream& input, 
        po::variables_map& variables)
    {
    }

    /**
     * Load command option definitions.
     * The implicit_value call allows flags to be strongly-typed on read while
     * allowing but not requiring a value on the command line for the option.
     * BUGBUG: see boost bug/fix: svn.boost.org/trac/boost/ticket/8009
     * @return  The loaded option definitions.
     */
    virtual po::options_description& load_options()
    {
        return option_metadata_;
    }
    
    /**
     * Load configuration setting definitions.
     * @param[out] definitions  The defined program argument definitions.
     */
    virtual void load_settings(po::options_description& definitions)
    {
        using namespace po;
        definitions.add_options()
.for configuration
.   is_last_configuration = last()
.   for setting
.       is_last_setting = is_last_configuration & last()
.       identifiers = section + "." + name
.       variable = "setting_." + pretty(section, "lower,c") + "." +\
            pretty(name, "lower,c")
.       expression = value_semantic(!true(), !true(), type,\
            is_xml_true(required), is_xml_true(multiple), variable, default)
            (
                "$(identifiers:)",
                $(expression),
                "$(description:)"
            )$(is_last_setting ?? ";")
.   endfor
.endfor
    }
	
	/**
     * Load streamed value as parameter fallback.
     * @param[in]  input      The input stream for loading the parameter.
     * @param[in]  variables  The loaded variables.
     */
    virtual void load_stream(std::istream& input, po::variables_map& variables)
	{
	}
    
    /**
     * Write the usage help for this command to the specified stream.
     * @param[out] stream  The output stream.
     */
    virtual void write_usage(std::ostream& stream)
    {
        auto options = load_options();
        auto arguments = load_arguments();
    } 
    
    /* Properties */
    
    /**
     * Get command line argument metadata.
     */
    virtual po::positional_options_description& get_argument_metadata()
    {
        return argument_metadata_;
    }
    
    /**
     * Get command line option metadata.
     */
    virtual po::options_description& get_option_metadata()
    {
        return option_metadata_;
    }

.for configuration
.   for setting
.       is_vector = is_xml_true(multiple)
.       setting_type = default_type(!true(), type)
.       vectored_type = vectored_type(setting_type, is_vector)
.       pluralized_name = pluralize(name, is_vector)
.       pluralized_setting = pluralize("setting", is_vector)
    /**
     * Get the value of the $(section:c).$(name:) $(pluralized_setting:).
     */
    virtual $(vectored_type:) get_$(section:c)_$(pluralized_name:c)_setting()
    {
        return setting_.$(section:c).$(pluralized_name:c);
    }

    /**
     * Set the value of the $(section:c).$(name:) $(pluralized_setting:).
     */
    virtual void set_$(section:c)_$(pluralized_name:c)_setting($(vectored_type:) value)
    {
        setting_.$(section:c).$(pluralized_name:c) = value;
    }
    
.   endfor
.endfor
protected:

    /**
     * This base class is abstract but not pure virtual, so prevent direct 
     * construction here.
     */
    command()
    {
    }
    
private:
    
    /**
     * Command line argument metadata.
     */
    po::positional_options_description argument_metadata_;

    /**
     * Command line option metadata.
     */
    po::options_description option_metadata_;
    
    /**
     * Environment variable bound variables.
     * Uses cross-compiler safe constructor-based zeroize.
     * Zeroize for unit test consistency with program_options initialization.
     */
    struct environment
    {
        environment()
        {
        }
        
.# There is no reason to expose the config path, as the config has been read.
.#      boost::filesystem::path config;
    } environment_;

    /**
     * Configuration setting file bound variables.
     * Uses cross-compiler safe constructor-based zeroize.
     * Zeroize for unit test consistency with program_options initialization.
     */
    struct setting
    {
.for configuration
        struct $(section:c)
        {
            $(section:c)()
.   for setting
.       is_vector = is_xml_true(multiple)
.       pluralized_name = pluralize(name, is_vector)
              $(if_else(first(), ":", " ")) $(pluralized_name:c)()$(!last() ?? ",")
.   endfor
            {
            }
            
.   for setting
.       is_vector = is_xml_true(multiple)
.       setting_type = default_type(!true(), type)
.       vectored_type = vectored_type(setting_type, is_vector)
.       pluralized_name = pluralize(name, is_vector)
            $(vectored_type:) $(pluralized_name:c);
.   endfor
        } $(section:c);

.endfor
        setting()
.for configuration
          $(if_else(first(), ":", " ")) $(section:c)()$(!last() ?? ",")
.endfor
        {
        }
    } setting_;
};

} // sx

#endif
.##############################################################################
.for command by symbol
.echo "Generating include/sx/command/$(symbol).hpp..."
.output "../include/sx/command/$(symbol).hpp"
.copyleft()
#ifndef SX_$(SYMBOL:c)_HPP
#define SX_$(SYMBOL:c)_HPP

#include <cstdint>
#include <iostream>
#include <string>
#include <vector>
#include <boost/program_options.hpp>
#include <bitcoin/bitcoin.hpp>
#include <sx/command.hpp>
#include <sx/define.hpp>
#include <sx/generated.hpp>
#include <sx/serializer/address.hpp>
#include <sx/serializer/base16.hpp>
#include <sx/serializer/base58.hpp>
#include <sx/serializer/btc.hpp>
#include <sx/serializer/btc160.hpp>
#include <sx/serializer/btc256.hpp>
#include <sx/serializer/ec_private.hpp>
#include <sx/serializer/ec_public.hpp>
#include <sx/serializer/encoding.hpp>
#include <sx/serializer/hashtype.hpp>
#include <sx/serializer/hd_key.hpp>
#include <sx/serializer/hd_priv.hpp>
#include <sx/serializer/hd_pub.hpp>
#include <sx/serializer/header.hpp>
#include <sx/serializer/input.hpp>
#include <sx/serializer/output.hpp>
#include <sx/serializer/prefix.hpp>
#include <sx/serializer/raw.hpp>
#include <sx/serializer/script.hpp>
#include <sx/serializer/stealth.hpp>
#include <sx/serializer/transaction.hpp>
#include <sx/serializer/wif.hpp>
#include <sx/serializer/wrapper.hpp>
#include <sx/utility/compat.hpp>
#include <sx/utility/config.hpp>
#include <sx/utility/utility.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

namespace sx {
namespace extension {
.for define
.   if first()

/**
 * Various localizable strings.
 */
.   endif
#define $(NAME:c) \\
    "$(value:)"
.endfor

/**
 * Class to implement the sx $(symbol:) command.
 */
class $(symbol:c) 
    : public command
{
public:

    /**
     * The symbolic (not localizable) command name, lower case.
     */
    static const char* symbol() { return "$(symbol:)"; }

    /**
     * The member symbolic (not localizable) command name, lower case.
     */
    virtual const char* name()
    {
        return $(symbol:c)::symbol();
    }

    /**
     * The localizable command category name, upper case.
     */
    virtual const char* category()
    {
        return "$(category:)";
    }

.
.# HACK: There must be a better way to count a collection.
.argument_count = 0
.for argument
.   argument_count += 1
.endfor
.option_count = 0
.for option
.   option_count += 1
.endfor
.
    /**
     * Load program argument definitions.
     * A value of -1 indicates that the number of instances is unlimited.
     * @return  The loaded program argument definitions.
     */
    virtual arguments_metadata& load_arguments()
    {
        return get_argument_metadata()$(if_else_empty(argument_count = 0, ";"))
.for argument
            .add("$(name:)", $(limit ? "1"))$(last() ?? ";")
.endfor
    }
	
	/**
     * Load parameter fallbacks from file or input as appropriate.
     * @param[in]  input  The input stream for loading the parameters.
     * @param[in]         The loaded variables.
     */
    virtual void load_fallbacks(std::istream& input, 
        po::variables_map& variables)
    {
.for argument
.   is_vector = !is_default(limit, 1)
.   argument_type = default_type(!true(), type)
.   pluralized_name = pluralize(name, is_vector)
.   getter = "get_" + "$(pluralized_name:c)" + "_argument()"
.#   bool_vector = if_else(is_vector, xml_true, xml_false)
.   if (is_xml_true(argument.file))
        load_path($(getter), "$(name:)", variables);
.   endif
.   if (is_xml_true(argument.stdin))
        load_input($(getter), "$(name:)", variables, input);
.   endif
.endfor
.for option
.   is_vector = is_xml_true(multiple)
.   option_type = default_type(true(), type)
.   pluralized_name = pluralize(name, is_vector)
.   getter = "get_" + "$(pluralized_name:c)" + "_option()"
.#   bool_vector = if_else(is_vector, xml_true, xml_false)
.   if (is_xml_true(option.file))
        load_path($(getter), "$(name:)", variables);
.   endif
.   if (is_xml_true(option.stdin))
        load_input($(getter), "$(name:)", variables, input);
.   endif
.endfor
    }
    
    /**
     * Load program option definitions.
     * The implicit_value call allows flags to be strongly-typed on read while
     * allowing but not requiring a value on the command line for the option.
     * BUGBUG: see boost bug/fix: svn.boost.org/trac/boost/ticket/8009
     * @return  The loaded program option definitions.
     */
    virtual options_metadata& load_options()
    {
        using namespace po;
        options_description& options = get_option_metadata();
        options.add_options()
            (
                SX_VARIABLE_CONFIG ",c",
                value<boost::filesystem::path>(),                 
                "$(config_description:)"
            )
.# TODO: How to block the description so as not to exceed max line length?
.for option
.   short_name = shortcut ? first_char(name)
.   identifiers = name
.   identifiers += if_else(short_name = "", "", "," + short_name)
.   variable = "option_." + pretty(name, "lower,c")
.   expression = value_semantic(is_xml_true(option.file), true(), type,\
        is_xml_true(required), is_xml_true(multiple), variable, default)
            (
                "$(identifiers:)",
                $(expression:),
                "$(description:)"
            )$((last() & (argument_count = 0)) ?? ";")
.endfor
.for argument
.   variable = "argument_." + pretty(name, "lower,c")
.   expression = value_semantic(is_xml_true(argument.file), !true(), type,\
        is_xml_true(required), !is_default(limit, 1), variable)
            (
                "$(name:)",
                $(expression:),
                "$(description:)"
            )$(last() ?? ";")
.endfor

        return options;
    }

    /**
     * Invoke the command.
     * @param[out]  output  The input stream for the command execution.
     * @param[out]  error   The input stream for the command execution.
     * @return              The appropriate console return code { -1, 0, 1 }.
     */
    virtual console_result invoke(std::ostream& output, std::ostream& cerr);
        
    /* Properties */

.for argument
.   is_vector = !is_default(limit, 1)
.   argument_type = default_type(!true(), type)
.   vtype = vectored_type(argument_type, is_vector)
.   pluralized_name = pluralize(name, is_vector)
.   pluralized_argument = pluralize("argument", is_vector)
    /**
     * Get the value of the $(name:) $(pluralized_argument:).
     */
    virtual $(vtype:)& get_$(pluralized_name:c)_argument()
    {
        return argument_.$(pluralized_name:c);
    }
    
    /**
     * Set the value of the $(name:) $(pluralized_argument:).
     */
    virtual void set_$(pluralized_name:c)_argument(
        const $(vtype:)& value)
    {
        argument_.$(pluralized_name:c) = value;
    }

.endfor
.for option
.   is_vector = is_xml_true(multiple)
.   option_type = default_type(true(), type)
.   vtype = vectored_type(option_type, is_vector)
.   pluralized_name = pluralize(name, is_vector)
.   pluralized_option = pluralize("option", is_vector)
    /**
     * Get the value of the $(name:) $(pluralized_option:).
     */
    virtual $(vtype:)& get_$(pluralized_name:c)_option()
    {
        return option_.$(pluralized_name:c);
    }
    
    /**
     * Set the value of the $(name:) $(pluralized_option:).
     */
    virtual void set_$(pluralized_name:c)_option(
        const $(vtype:)& value)
    {
        option_.$(pluralized_name:c) = value;
    }

.endfor
private:

    /**
     * Command line argument bound variables.
     * Uses cross-compiler safe constructor-based zeroize.
     * Zeroize for unit test consistency with program_options initialization.
     */
    struct argument
    {
        argument()
.for argument
.   is_vector = !is_default(limit, 1)
.   pluralized_name = pluralize(name, is_vector)
          $(if_else(first(), ":", " ")) $(pluralized_name:c)()$(!last() ?? ",")
.   endfor
        {
        }
        
.for argument
.   is_vector = !is_default(limit, 1)
.   argument_type = default_type(!true(), type)
.   vector_type = vectored_type(argument_type, is_vector)        
.   pluralized_name = pluralize(name, is_vector)
        $(vector_type:) $(pluralized_name:c);
.endfor            
    } argument_;
    
    /**
     * Command line option bound variables.
     * Uses cross-compiler safe constructor-based zeroize.
     * Zeroize for unit test consistency with program_options initialization.
     */
    struct option
    {
        option()
.for option
.   is_vector = is_xml_true(multiple)
.   pluralized_name = pluralize(name, is_vector)
          $(if_else(first(), ":", " ")) $(pluralized_name:c)()$(!last() ?? ",")
.endfor
        {
        }
        
.for option
.   is_vector = is_xml_true(multiple)
.   option_type = default_type(true(), type)
.   vector_type = vectored_type(option_type, is_vector)
.   pluralized_name = pluralize(name, is_vector)
        $(vector_type:) $(pluralized_name:c);
.endfor
    } option_;
};

} // extension
} // sx

#endif
.endfor
.##############################################################################
.echo "Generating test/generated__broadcast.cpp..."
.output "../test/generated__broadcast.cpp"
.copyleft()
#include "precompile.hpp"
#include <boost/test/unit_test.hpp>

#include <sx/sx.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

BOOST_AUTO_TEST_SUITE(generated__broadcast)

BOOST_AUTO_TEST_CASE(generated__broadcast__always__returns_true)
{
    // TODO: mocks and dependency injection required to test proper execution.
    auto func = [](std::shared_ptr<sx::command> sx_command) -> void {};
    BOOST_REQUIRE(sx::broadcast(func));
}

BOOST_AUTO_TEST_SUITE_END()
.##############################################################################
.echo "Generating test/generated__find.cpp..."
.output "../test/generated__find.cpp"
.copyleft()
#include "precompile.hpp"
#include <boost/test/unit_test.hpp>

#include <sx/sx.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

using namespace sx;
using namespace sx::extension;

BOOST_AUTO_TEST_SUITE(generated__find)
.for command by symbol

BOOST_AUTO_TEST_CASE(generated__find__$(symbol:c)__returns_object)
{
    BOOST_REQUIRE(find($(symbol:c)::symbol()) != nullptr);
}
.endfor

BOOST_AUTO_TEST_SUITE_END()
.##############################################################################
.echo "Generating test/generated__symbol.cpp..."
.output "../test/generated__symbol.cpp"
.copyleft()
#include "precompile.hpp"
#include <boost/test/unit_test.hpp>

#include <sx/sx.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

using namespace sx;
using namespace sx::extension;

BOOST_AUTO_TEST_SUITE(generated__symbol)
.for command by symbol

BOOST_AUTO_TEST_CASE(generated__symbol__$(symbol:c)__returns_expected_value)
{
    BOOST_REQUIRE($(symbol:c)::symbol() == std::string("$(symbol:)"));
}
.endfor

BOOST_AUTO_TEST_SUITE_END()
.##############################################################################
.echo "Generating include/Makefile.am..."
.output "../include/Makefile.am"
# ******** GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY ********* #

sx_includedir = $\(includedir)/sx
sx_include_HEADERS = \\
    async_client.hpp \\
    callback_state.hpp \\
    command.hpp \\
    define.hpp \\
    dispatch.hpp \\
    display.hpp \\
    generated.hpp \\
    obelisk_client.hpp \\
    prop_tree.hpp \\
    sx.hpp

sx_utility_includedir = $\(includedir)/sx/utility
sx_utility_include_HEADERS += \\
    compat.hpp \\
    config.hpp \\
    environment.hpp \\
    parameter.hpp \\
    printer.hpp \\
    utility.hpp
    
sx_utility_includedir = $\(includedir)/sx/serializer
sx_utility_include_HEADERS += \\
    address.hpp \\
    base16.hpp \\
    base58.hpp \\
    btc.hpp \\
    btc160.hpp \\
    btc256.hpp \\
    ec_private.hpp \\
    ec_public.hpp \\
    encoding.hpp \\
    hashtype.hpp \\
    hd_key.hpp \\
    hd_priv.hpp \\
    hd_pub.hpp \\
    header.hpp \\
    history.hpp \\
    input.hpp \\
    output.hpp \\
    point.hpp \\
    prefix.hpp \\
    raw.hpp \\
    script.hpp \\
    stealth.hpp \\
    transaction.hpp \\
    wif.hpp \\
    wrapper.hpp

# Generated from XML data source.
sx_command_includedir = $\(includedir)/sx/command
sx_command_include_HEADERS = \\
.for command by symbol where !is_xml_true(obelisk)
    command/$(symbol:).hpp$(!last() ?? " \\")
.endfor

# Generated from XML data source.
if HAVE_OBELISK
    sx_command_include_HEADERS += \\
.for command by symbol where is_xml_true(obelisk)
        command/$(symbol:).hpp$(!last() ?? " \\")
.endfor
endif
.##############################################################################
.echo "Generating src/Makefile.am..."
.output "../src/Makefile.am"
# ******** GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY ********* #

AUTOMAKE_OPTIONS = subdir-objects

# Library
noinst_LTLIBRARIES = libsx.la

AM_CPPFLAGS = \\
    ${libbitcoin_CFLAGS} \\
    ${libwallet_CFLAGS} \\
    -I$\(srcdir)/../include

libsx_la_SOURCES = \\
    async_client.cpp \\
    callback_state.cpp \\
    dispatch.cpp \\
    display.cpp \\
    generated.cpp \\
    prop_tree.cpp \\
    serializer/address.hpp \\
    serializer/base16.hpp \\
    serializer/base58.hpp \\
    serializer/btc.hpp \\
    serializer/btc160.hpp \\
    serializer/btc256.hpp \\
    serializer/ec_private.hpp \\
    serializer/ec_public.hpp \\
    serializer/encoding.hpp \\
    serializer/hashtype.hpp \\
    serializer/hd_key.hpp \\
    serializer/hd_priv.hpp \\
    serializer/hd_pub.hpp \\
    serializer/header.hpp \\
    serializer/input.hpp \\
    serializer/output.hpp \\
    serializer/point.hpp \\
    serializer/prefix.hpp \\
    serializer/raw.hpp \\
    serializer/script.hpp \\
    serializer/stealth.hpp \\
    serializer/transaction.hpp \\
    serializer/wif.hpp \\
    serializer/wrapper.hpp \\
    utility/config.cpp \\
    utility/environment.cpp \\
    utility/parameter.cpp \\
    utility/printer.cpp \\
    utility/utility.cpp

# Generated from XML data source.
libsx_la_SOURCES += \\
.for command by symbol where !is_xml_true(obelisk)
    $(symbol:).cpp$(!last() ?? " \\")
.endfor

# Generated from XML data source.
if HAVE_OBELISK
    libsx_la_SOURCES += \\
.for command by symbol where is_xml_true(obelisk)
        $(symbol:).cpp \\
.endfor
        obelisk_client.cpp

    AM_CPPFLAGS += \\
        ${libobelisk_CFLAGS} \\
        -DSYSCONFDIR=\"${sysconfdir}\"
endif

# Console Application
bin_PROGRAMS = sx

sx_SOURCES = \\
    console/main.cpp

sx_LDADD = \\
    -L$\(srcdir) -lsx \\
    $\(libbitcoin_LIBS) \\
    $\(libwallet_LIBS) \\
    -lboost_filesystem \\
    -lboost_program_options \\
    -lboost_regex \\
    -lboost_system

if HAVE_OBELISK
    sx_LDADD += \\
        $\(libobelisk_LIBS)
endif
.##############################################################################
.echo "Generating builds/msvc/vs2013/libsx/libsx.vcxproj..."
.output "../builds/msvc/vs2013/libsx/libsx.vcxproj"
<?xml version="1.0" encoding="utf-8"?>
<!--
#################################################################
#   GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY    #
#################################################################
-->
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <NuGetPackageImportStamp>82a52cd0</NuGetPackageImportStamp>
    <PlatformToolset>CTP_Nov2013</PlatformToolset>
    <ProjectGuid>{4A1D71D5-3DEE-47F0-A189-21C301E2808F}</ProjectGuid>
    <ProjectName>libsx</ProjectName>
  </PropertyGroup>
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="DebugDLL|Win32">
      <Configuration>DebugDLL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseDLL|Win32">
      <Configuration>ReleaseDLL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugDLL|x64">
      <Configuration>DebugDLL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseDLL|x64">
      <Configuration>ReleaseDLL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLTCG|Win32">
      <Configuration>DebugLTCG</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLTCG|Win32">
      <Configuration>ReleaseLTCG</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLTCG|x64">
      <Configuration>DebugLTCG</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLTCG|x64">
      <Configuration>ReleaseLTCG</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLIB|Win32">
      <Configuration>DebugLIB</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLIB|Win32">
      <Configuration>ReleaseLIB</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLIB|x64">
      <Configuration>DebugLIB</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLIB|x64">
      <Configuration>ReleaseLIB</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType Condition="$\(Configuration.IndexOf('DLL')) == -1">StaticLibrary</ConfigurationType>
    <ConfigurationType Condition="$\(Configuration.IndexOf('DLL')) != -1">DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <Import Project="$\(VCTargetsPath)\\Microsoft.Cpp.Default.props" />
  <Import Project="$\(VCTargetsPath)\\Microsoft.Cpp.props" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$\(ProjectDir)..\\..\\properties\\$\(Configuration).props" />
    <Import Project="$\(ProjectDir)..\\..\\properties\\Output.props" />
    <Import Project="$\(ProjectDir)$\(ProjectName).props" />
  </ImportGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\sx.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\callback_state.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\async_client.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\define.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\dispatch.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\display.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\generated.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\obelisk_client.hpp">
      <ExcludedFromBuild Condition="'$\(Option-obelisk)' != 'true'">true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\prop_tree.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\address.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\base16.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\base58.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\btc.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\btc160.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\btc256.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\ec_private.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\ec_public.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\encoding.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hashtype.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hd_key.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hd_priv.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hd_pub.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\header.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\input.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\output.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\point.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\prefix.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\raw.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\script.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\stealth.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\transaction.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\wif.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\wrapper.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\compat.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\config.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\environment.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\parameter.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\printer.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\utility.hpp" />
  </ItemGroup>
  <ItemGroup>
.for command by symbol
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command\\$(symbol:).hpp" />
.endfor
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\\..\\..\\..\\src\\async_client.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\callback_state.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\dispatch.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\display.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\generated.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\obelisk_client.cpp">
      <ExcludedFromBuild Condition="'$\(Option-obelisk)' != 'true'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\prop_tree.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\address.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\base16.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\base58.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\btc.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\btc160.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\btc256.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\ec_private.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\ec_public.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\encoding.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hashtype.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hd_key.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hd_priv.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hd_pub.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\header.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\input.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\output.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\point.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\prefix.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\raw.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\script.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\stealth.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\transaction.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\wif.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\wrapper.cpp" />    
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\config.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\environment.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\parameter.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\printer.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\utility.cpp" />
  </ItemGroup>
  <ItemGroup>
.for command by symbol
.   if (!is_xml_true(obelisk))
    <ClCompile Include="..\\..\\..\\..\\src\\$(symbol:).cpp" />
.   else
    <ClCompile Include="..\\..\\..\\..\\src\\$(symbol:).cpp">
.       if (is_xml_true(obelisk))
      <ExcludedFromBuild Condition="'$\(Option-obelisk)' != 'true'">true</ExcludedFromBuild>
.       endif
    </ClCompile>
.   endif
.endfor
  </ItemGroup>
  <Import Project="$\(VCTargetsPath)\\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.56.0.0\\build\\native\\boost_filesystem.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.56.0.0\\build\\native\\boost_filesystem.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem-vc120.1.56.0.0\\build\\native\\boost_filesystem-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem-vc120.1.56.0.0\\build\\native\\boost_filesystem-vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.56.0.0\\build\\native\\boost_program_options-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.56.0.0\\build\\native\\boost_program_options-vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.56.0.0\\build\\native\\boost_regex-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.56.0.0\\build\\native\\boost_regex-vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost.1.56.0.0\\build\\native\\boost.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost.1.56.0.0\\build\\native\\boost.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_thread-vc120.1.56.0.0\\build\\native\\boost_thread-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_thread-vc120.1.56.0.0\\build\\native\\boost_thread-vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.6.0.1\\build\\native\\libsodium_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.6.0.1\\build\\native\\libsodium_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.800\\build\\native\\openssl_no-asm_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.800\\build\\native\\openssl_no-asm_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.56.0.0\\build\\native\\boost_system-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.56.0.0\\build\\native\\boost_system-vc120.targets')" />
  </ImportGroup>
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.56.0.0\\build\\native\\boost_filesystem.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.56.0.0\\build\\native\\boost_filesystem.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem-vc120.1.56.0.0\\build\\native\\boost_filesystem-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem-vc120.1.56.0.0\\build\\native\\boost_filesystem-vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.56.0.0\\build\\native\\boost_program_options-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.56.0.0\\build\\native\\boost_program_options-vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.56.0.0\\build\\native\\boost_regex-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.56.0.0\\build\\native\\boost_regex-vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost.1.56.0.0\\build\\native\\boost.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost.1.56.0.0\\build\\native\\boost.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_thread-vc120.1.56.0.0\\build\\native\\boost_thread-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_thread-vc120.1.56.0.0\\build\\native\\boost_thread-vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.6.0.1\\build\\native\\libsodium_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.6.0.1\\build\\native\\libsodium_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.800\\build\\native\\openssl_no-asm_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.800\\build\\native\\openssl_no-asm_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.56.0.0\\build\\native\\boost_system-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.56.0.0\\build\\native\\boost_system-vc120.targets'))" />
  </Target>
</Project>
.##############################################################################
.echo "Generating builds/msvc/vs2013/libsx/libsx.vcxproj.filter..."
.output "../builds/msvc/vs2013/libsx/libsx.vcxproj.filters"
<?xml version="1.0" encoding="utf-8"?>
<!--
#################################################################
#   GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY    #
#################################################################
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="include\\command">
      <UniqueIdentifier>{8f3f62c0-53c7-4044-a1da-c3fcc9d27651}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\\command\\obelisk">
      <UniqueIdentifier>{E9B42E1D-5F9D-41FA-AB9B-75D15069071C}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\\command\\obsolete">
      <UniqueIdentifier>{268700C7-1C9D-44FF-B1CE-3104893288A4}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\\command\\stub">
      <UniqueIdentifier>{1A3D8C7D-8801-42D9-8420-A7E95CD259AE}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\\serializer">
      <UniqueIdentifier>{3857250F-34CC-43E4-9781-68B9E01BBD9D}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\\utility">
      <UniqueIdentifier>{dc28e2c9-d07d-4242-8007-e44440c133a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="include">
      <UniqueIdentifier>{f75d4585-8ee2-45e8-96ec-880c63fc243e}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\command\\obelisk">
      <UniqueIdentifier>{4085fba5-b358-4b3f-968f-ee8be943775f}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\command\\obsolete">
      <UniqueIdentifier>{DF81EBEE-BB03-406B-B4C5-1D9FD2964E97}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\command\\stub">
      <UniqueIdentifier>{e96f4bef-2d18-4897-9078-a8c17783ee65}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\command">
      <UniqueIdentifier>{4085fba5-b358-4b3f-968f-ee8be943775f}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\serializer">
      <UniqueIdentifier>{6CE1C682-2E57-4EA8-B819-5C733184121A}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\utility">
      <UniqueIdentifier>{c50b43cf-9009-45a6-b813-7a61877602f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="src">
      <UniqueIdentifier>{6afc4dd0-6330-4dca-b176-cd4887f27b9f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
.for command by symbol
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command\\$(symbol:).hpp">
.   if (is_xml_true(stub))
      <Filter>include\\command\\stub</Filter>
.   elsif (is_xml_true(obelisk))
      <Filter>include\\command\\obelisk</Filter>
.   elsif (is_xml_true(obsolete))
      <Filter>include\\command\\obsolete</Filter>
.   else
      <Filter>include\\command</Filter>
.   endif
    </ClInclude>
.endfor
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\address.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\base16.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\base58.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\btc.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\btc160.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\btc256.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\ec_private.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\ec_public.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hd_key.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\encoding.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hashtype.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hd_priv.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\hd_pub.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\header.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\input.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\output.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\point.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\prefix.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\raw.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\script.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\stealth.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\transaction.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\wif.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\serializer\\wrapper.hpp">
      <Filter>include\\serializer</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\compat.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\config.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\environment.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\parameter.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\printer.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\utility.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\async_client.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\callback_state.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\define.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\dispatch.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\display.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\generated.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\obelisk_client.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\prop_tree.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\sx.hpp">
      <Filter>include</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
.for command by symbol
    <ClCompile Include="..\\..\\..\\..\\src\\$(symbol:).cpp">
.   if (is_xml_true(stub))
      <Filter>src\\command\\stub</Filter>
.   elsif (is_xml_true(obelisk))
      <Filter>src\\command\\obelisk</Filter>
.   elsif (is_xml_true(obsolete))
      <Filter>src\\command\\obsolete</Filter>
.   else
      <Filter>src\\command</Filter>
.   endif
    </ClCompile>
.endfor
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\address.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\base16.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\base58.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\btc.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\btc160.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\btc256.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\ec_private.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\ec_public.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hashtype.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hd_key.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\encoding.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hd_priv.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\hd_pub.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\header.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\input.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\output.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\point.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\prefix.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\raw.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\script.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\stealth.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\transaction.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\wif.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\serializer\\wrapper.cpp">
      <Filter>src\\serializer</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\config.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\environment.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\parameter.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\printer.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\utility.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\async_client.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\callback_state.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\dispatch.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\display.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\generated.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\obelisk_client.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\prop_tree.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
.##############################################################################