.#  Generate C++ source and make files for SX
.#
.#  This is a code generator built using the iMatix GSL code generation
.#  language. See https://github.com/imatix/gsl for details.
.#
.##############################################################################
.# This section is a GSL define/macro/function library.
.
.xml_false = "false"
.xml_true = "true"
.
.macro global.copyleft
/**
 * Copyright (c) 2011-2014 sx developers (see AUTHORS)
 *
 * This file is part of sx.
 *
 * sx is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License with
 * additional permissions to the one published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version. For more information see LICENSE.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
.endmacro
.
.function global.first_char(value)
.   return string.substr(my.value, 0, 0)
.endfunction
.
.function global.format_c(text)
    return my.text
.endfunction
.
.function global.if_else(antecedent, consequent, alternate)
.   return my.antecedent ?? my.consequent ? my.alternate
.endfunction
.
.function global.is_default(value, default_value)
.   return conv.number(my.value ? my.default_value) = my.default_value
.endfunction
.
.function global.is_empty(value)
.   return ((my.value ? "") = "")
.endfunction
.
.function global.is_true(value)
.   return ((my.value ? xml_false) = xml_true)
.endfunction
.
.# TODO: Get type map from XML data source.
.function global.normalize_type(type)
.   if my.type = "string"
.       return "std::" + my.type
.   endif
.   if my.type = "path"
.       return "boost::filesystem::" + my.type
.   endif
.   return my.type
.endfunction
.
.function global.pluralize(name, is_plural)
.   return my.name + if_else(my.is_plural, "s", "")
.endfunction
.
.function global.true()
.   return 0 = 0
.endfunction
.
.function global.type_default(is_option, type, required, unlimited)
.   is_toggle = my.is_option & (is_empty(my.type) | my.required | my.unlimited)
.   return normalize_type(if_else(is_toggle, "bool", my.type ? "string"))
.endfunction 
.
.function global.value_semantic(is_option, type, required, unlimited,\
    variable, fallback)
.   is_toggle = my.is_option & (is_empty(my.type) | my.required | my.unlimited)
.   type_value = normalize_type(if_else(is_toggle, "bool", my.type ? "string"))
.   defaulted = !is_empty(my.fallback)
.   quote_default = defaulted &\
        (type_value = "boost::filesystem::path") |\
        (type_value = "std::string")
.   default_value = if_else(quote_default, "\"", "")
.   default_value += if_else(defaulted, "$(my.fallback:)", "")
.   default_value += if_else(quote_default, "\"", "")
.   binding = if_else(is_empty(my.variable), "", "&" + my.variable)
.   expression = "value<"
.   expression += vectored_type(type_value, my.unlimited)
.   expression += ">($(binding:))"
.   expression += if_else(my.required, "->required()", "")
.   expression += if_else(defaulted, "->default_value($(default_value:))", "")
.   expression += if_else(is_toggle, "->implicit_value(true)", "")
.   return expression
.endfunction
.
.function global.vectored_type(type, is_vector)
.   vectored = if_else(my.is_vector, "std::vector<", "")
.   vectored += my.type
.   vectored += if_else(my.is_vector, ">", "")
.   return vectored
.endfunction
.##############################################################################
.echo "Generating include/sx/generated.hpp..."
.output "../include/sx/generated.hpp"
.global.copyleft()
#ifndef SX_GENERATED_HPP
#define SX_GENERATED_HPP

#include <functional>
#include <memory>
#include <string>
#include <boost/program_options.hpp>
#include <sx/command.hpp>
.for command by symbol
#include <sx/command/$(symbol).hpp>
.endfor

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

#define SX_VARIABLE_CONFIG "config"

namespace po = boost::program_options;

namespace sx {

/**
 * Convenience type that prevents conflict with use of common symbol 'error'.
 */
typedef po::error options_exception;

/**
 * Invoke a specified function on all commands.
 *
 * @param[in]  func  The function to invoke on all commands.
 * @return           True if invoked successfully.
 */
bool broadcast(const std::function<void(std::shared_ptr<command>)> func);

/**
 * Find the command identified by the specified symbolic command name.
 *
 * @param[in]  symbol  The symbolic command name.
 * @return             An instance of the command or nullptr if not found.
 */
std::shared_ptr<command> find(const std::string& symbol);

} // sx

#endif
.##############################################################################
.echo "Generating src/generated.cpp..."
.output "../src/generated.cpp"
.global.copyleft()
#include <functional>
#include <memory>
#include <string>
#include <vector>
#include <sx/command.hpp>
#include <sx/generated.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

using namespace po;
using namespace std;
using namespace boost::filesystem;
    
namespace sx {
using namespace extensions;

bool broadcast(const function<void(shared_ptr<command>)> func)
{
.for command by symbol
    func(make_shared<$(symbol:c)>());
.endfor

    return true;
}

shared_ptr<command> find(const string& symbol)
{
.for command by symbol
    if (symbol == $(symbol:c)::symbol())
        return make_shared<$(symbol:c)>();
.endfor

    return nullptr;
}

} // sx
.##############################################################################
.echo "Generating include/sx/command.hpp..."
.output "../include/sx/command.hpp"
.global.copyleft()
#ifndef SX_COMMAND_HPP
#define SX_COMMAND_HPP

#include <string>
#include <vector>
#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>
#include <sx/utility/config.hpp>
#include <sx/utility/console.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

namespace sx {

#define SX_VARIABLE_CONFIG "config"

/**
 * Abstract base class for definition of each SX command.
 */
class command
{
public:

    /**
     * The symbolic (not localizable) command name, lower case.
     */
    static const char* symbol() { return "not-implemented"; }

    /**
     * The symbolic (not localizable) command name, lower case.
     *
     * @return  Exmaple: "fetch-transaction"
     */
    virtual const char* name()
    {
        return symbol();
    }

    /**
     * The localizable command category name, upper case.
     *
     * @return  Example: "ONLINE (OBELISK)"
     */
    virtual const char* category()
    {
        return symbol();
    }

    /**
     * The localizable command subcategory name, upper case.
     *
     * @return  Example: "BLOCKCHAIN QUERIES"
     */
    virtual const char* subcategory()
    {
        return symbol();
    }

    /**
     * The localizable command description, multiple lines, punctuated.
     *
     * @return  Example:
     * "Fetch a raw transaction using a network connection to"
     * "make requests against the obelisk load balancer back end."
     */
    virtual const std::vector<const char*> description()
    {
        return { symbol() };
    }

    /**
     * The non-localizable command usage examples, multiple lines.
     *
     * @return  Example:
     * "sx fetch-transaction HASH"
     */
    virtual const std::vector<const char*> example()
    {
        return { symbol() };
    }

    /**
     * The localizable command explanation, multiple lines, punctuated.
     *
     * @return  Example:
     * "$ sx fetch-transaction ... # fetches raw data"
     */
    virtual const std::vector<const char*> explanation()
    {
        return { symbol() };
    }
    
    /**
     * Invoke the command.
     *
     * @return  The appropriate console return code { -1, 0, 1 }.
     */
    virtual console_result invoke()
    {
        return console_result::failure;
    }

    /**
     * Load command argument definitions.
     * A value of -1 indicates that the number of instances is unlimited.
     *
     * @param[out] definitions  The defined program argument definitions.
     */
    virtual void load_arguments(
        boost::program_options::positional_options_description& definitions)
    {
    }

    /**
     * Load environment variable definitions.
     *
     * @param[out] definitions  The defined program argument definitions.
     */
    virtual void load_environment(
        boost::program_options::options_description& definitions)
    {
        using namespace boost::program_options;
        definitions.add_options()
            /* This composes with the command line options. */
            (
                SX_VARIABLE_CONFIG, 
                value<boost::filesystem::path>()
                    ->composing()->default_value(config_default()),
                "The path and file name for the configuration settings file for this application."
            );
    }

    /**
     * Load command option definitions.
     * The implicit_value call allows flags to be strongly-typed on read while
     * allowing but not requiring a value on the command line for the option.
     *
     * BUGBUG: see boost bug/fix: svn.boost.org/trac/boost/ticket/8009
     *
     * @param[out] definitions  The defined program option definitions.
     */
    virtual void load_options(
        boost::program_options::options_description& definitions)
    {
    }
    
    /**
     * Load configuration setting definitions.
     *
     * @param[out] definitions  The defined program argument definitions.
     */
    virtual void load_settings(
        boost::program_options::options_description& definitions)
    {
        using namespace boost::program_options;
        definitions.add_options()
.for configuration
.   is_last_configuration = last()
.   for setting
.       is_last_setting = is_last_configuration & last()
.       identifiers = section + "." + name
.       variable = "settings." + global.format_c(section) + "." +\
            global.format_c(name)
.       expression = global.value_semantic(!global.true(), type,\
            is_true(required), is_true(multiple), variable, default)
            (
                "$(identifiers:)",
                $(expression),
                "$(description:)"
            )$(is_last_setting ?? ";")
.   endfor
.endfor
    }      

protected:

    /**
     * This base class is abstract but not pure virtual, so prevent direct 
     * construction here.
     */
    command() {}

    /**
     * Configuration settings file bound variables.
     */
    struct
    {
.for configuration
        struct
        {
.   for setting
.       is_vector = is_true(multiple)
.       setting_type = global.type_default(!global.true(), type,\
            is_true(required), is_vector)
.       vectored_type = global.vectored_type(setting_type, is_vector)
.       pluralized_name = global.pluralize(name, is_vector)      
            $(vectored_type:) $(pluralized_name:c);
.   endfor
        } $(section:c);
.endfor
    } settings;
    
    /**
     * Environment variable bound variables.
     */
    struct
    {
        boost::filesystem::path config;
    } environment;
};

} // sx

#endif
.##############################################################################
.for command by symbol
.echo "Generating include/sx/command/$(symbol).hpp..."
.output "../include/sx/command/$(symbol).hpp"
.global.copyleft()
#ifndef SX_$(SYMBOL:c)_HPP
#define SX_$(SYMBOL:c)_HPP

#include <stdint.h>
#include <string>
#include <vector>
#include <boost/program_options.hpp>
#include <sx/command.hpp>
#include <sx/generated.hpp>
#include <sx/utility/compat.hpp>
#include <sx/utility/config.hpp>
#include <sx/utility/console.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

namespace sx {
namespace extensions {
.for define
.   if first()

/**
 * Various localizable strings.
 */
.   endif
#define $(SYMBOL:c) \\
    "$(value:)"
.endfor

/**
 * Class to implement the sx $(symbol:) command.
 */
class $(symbol:c) 
    : public command
{
public:

    /**
     * The symbolic (not localizable) command name, lower case.
     */
    static const char* symbol() { return "$(symbol:)"; }

    /**
     * The member symbolic (not localizable) command name, lower case.
     */
    const char* name()
    {
        return $(symbol:c)::symbol();
    }

    /**
     * The localizable command category name, upper case.
     */
    const char* category()
    {
        return "$(category:)";
    }

    /**
     * The localizable command subcategory name, upper case.
     */
    const char* subcategory()
    {
        return "$(subcategory:)";
    }

    /**
     * The localizable command description, multiple lines, punctuated.
     */
    const std::vector<const char*> description()
    {
        return
        {
.for description
            { "$(value:)" }$(last() ?? ",")
.endfor
        };
    }

    /**
     * The non-localizable command usage examples, multiple lines.
     */
    const std::vector<const char*> example()
    {
        return
        {
.for example
            { "$(value:)" }$(last() ?? ",")
.endfor
        };
    }

    /**
     * The localizable command explanation, multiple lines, punctuated.
     */
    const std::vector<const char*> explanation()
    {
        return
        {
.for explanation
            { "$(value:)" }$(last() ?? ",")
.endfor
        };
    }
    
    /**
     * Load program argument definitions.
     * A value of -1 indicates that the number of instances is unlimited.
     *
     * @param[out] definitions  The defined program argument definitions.
     */
    void load_arguments(
        boost::program_options::positional_options_description& definitions)
    {
.for argument
        definitions.add("$(name:)", $(limit ? "1"));
.endfor          
    }
    
    /**
     * Load program option definitions.
     * The implicit_value call allows flags to be strongly-typed on read while
     * allowing but not requiring a value on the command line for the option.
     *
     * BUGBUG: see boost bug/fix: svn.boost.org/trac/boost/ticket/8009
     *
     * @param[out] definitions  The defined program option definitions.
     */
    void load_options(
        boost::program_options::options_description& definitions)
    {
        using namespace boost::program_options;
        definitions.add_options()
            (
                SX_VARIABLE_CONFIG ",c",
                value<boost::filesystem::path>(),
                "The path and file name for the configuration settings file for this application."
            )
.
.# HACK: There must be a better way to count a collection.
.argument_count = 0
.for argument
.   argument_count += 1
.endfor
.
.# TODO: How to block the description so as not to exceed max line length?
.for option
.   short_name = shortcut ? global.first_char(name)
.   identifiers = name
.   identifiers += if_else(short_name = "", "", "," + short_name)
.   variable = "option." + global.format_c(name)
.   expression = global.value_semantic(global.true(), type,\
        is_true(required), is_true(multiple), variable, default)
            (
                "$(identifiers:)",
                $(expression:),
                "$(description:)"
            )$((last() & (argument_count = 0)) ?? ";")
.endfor
.for argument
.   expression = global.value_semantic(!global.true(), type,\
        is_true(required), !is_default(limit, 1), name)
            (
                "$(name:)",
                $(expression:),
                "$(description:)"
            )$(last() ?? ";")
.endfor
    }   

    /**
     * Invoke the command.
     *
     * @return  The appropriate console return code { -1, 0, 1 }.
     */
    console_result invoke();
    
protected:

    /**
     * Command line argument bound variables.
     */
    struct
    {
.for argument
.   is_vector = !is_default(limit, 1)
.   argument_type = global.type_default(!global.true(), type,\
        is_true(required), is_vector)
.   vectored_type = global.vectored_type(argument_type, is_vector)        
.   pluralized_name = global.pluralize(name, is_vector)      
        $(vectored_type:) $(pluralized_name:c);
.endfor
    } argument;
    
    /**
     * Command line option bound variables.
     */
    struct
    {
.for option
.   is_vector = is_true(multiple)
.   option_type = global.type_default(global.true(), type,\
        is_true(required), is_vector)
.   vectored_type = global.vectored_type(option_type, is_vector)
.   pluralized_name = global.pluralize(name, is_vector)      
        $(vectored_type:) $(pluralized_name:c);
.endfor
    } option;
};

} // extensions
} // sx

#endif
.endfor
.##############################################################################
.echo "Generating test/generated_find.cpp..."
.output "../test/generated_find.cpp"
.global.copyleft()
#include <boost/test/unit_test.hpp>
#include <sx/sx.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

using namespace sx;
using namespace sx::extensions;

BOOST_AUTO_TEST_SUITE(generated_find)
.for command by symbol

BOOST_AUTO_TEST_CASE(find_$(symbol:c)_returns_object)
{
    BOOST_REQUIRE(find($(symbol:c)::symbol()) != nullptr);
}
.endfor

BOOST_AUTO_TEST_SUITE_END()
.##############################################################################
.echo "Generating test/generated_symbol.cpp..."
.output "../test/generated_symbol.cpp"
.global.copyleft()
#include <boost/test/unit_test.hpp>
#include <sx/sx.hpp>

/********* GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY **********/

using namespace sx;
using namespace sx::extensions;

BOOST_AUTO_TEST_SUITE(generated_symbol)
.for command by symbol

BOOST_AUTO_TEST_CASE(find_$(symbol:c)_returns_expected_value)
{
    BOOST_REQUIRE($(symbol:c)::symbol() == std::string("$(symbol:)"));
}
.endfor

BOOST_AUTO_TEST_SUITE_END()
.##############################################################################
.echo "Generating include/Makefile.am..."
.output "../include/Makefile.am"
# ******** GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY ********* #

sx_includedir = $\(includedir)/sx
sx_include_HEADERS = \\
    command.hpp \\
    dispatch.hpp \\
    display.hpp \\
    obelisk.hpp \\
    sx.hpp

sx_utility_includedir = $\(includedir)/sx/utility
sx_utility_include_HEADERS += \\
    coin.hpp \\
    compat.hpp \\
    config.hpp \\
    console.hpp \\
    environment.hpp

# Generated from XML data source.
sx_command_includedir = $\(includedir)/sx/command
sx_command_include_HEADERS = \\
.for command by symbol where !global.is_true(obelisk)
    command/$(symbol:).hpp$(!last() ?? " \\")
.endfor

# Generated from XML data source.
if HAVE_OBELISK
    sx_command_include_HEADERS += \\
.for command by symbol where global.is_true(obelisk)
        command/$(symbol:).hpp$(!last() ?? " \\")
.endfor
endif
.##############################################################################
.echo "Generating src/Makefile.am..."
.output "../src/Makefile.am"
# ******** GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY ********* #

AUTOMAKE_OPTIONS = subdir-objects

# Library
noinst_LTLIBRARIES = libsx.la

AM_CPPFLAGS = \\
    ${libbitcoin_CFLAGS} \\
    ${libwallet_CFLAGS} \\
    -I$\(srcdir)/../include

libsx_la_SOURCES = \\
    dispatch.cpp \\
    display.cpp \\
    generated.cpp \\
    utility/coin.cpp \\
    utility/config.cpp \\
    utility/console.cpp \\
    utility/environment.cpp

# Generated from XML data source.
libsx_la_SOURCES += \\
.for command by symbol where !global.is_true(obelisk)
    $(symbol:).cpp$(!last() ?? " \\")
.endfor

# Generated from XML data source.
if HAVE_OBELISK
    libsx_la_SOURCES += \\
.for command by symbol where global.is_true(obelisk)
        $(symbol:).cpp \\
.endfor
        obelisk.cpp

    AM_CPPFLAGS += \\
        ${libobelisk_CFLAGS} \\
        -DSYSCONFDIR=\"${sysconfdir}\"
endif

# Console Application
bin_PROGRAMS = sx

sx_SOURCES = \\
    console/main.cpp

sx_LDADD = \\
    -L$\(srcdir) -lsx \\
    $\(libbitcoin_LIBS) \\
    $\(libwallet_LIBS) \\
    -lboost_filesystem \\
    -lboost_program_options \\
    -lboost_regex \\
    -lboost_system

if HAVE_OBELISK
    sx_LDADD += \\
        $\(libobelisk_LIBS) \\
        -lncurses
endif
.##############################################################################
.echo "Generating builds/msvc/vs2013/libsx/libsx.vcxproj..."
.output "../builds/msvc/vs2013/libsx/libsx.vcxproj"
<?xml version="1.0" encoding="utf-8"?>
<!--
#################################################################
#   GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY    #
#################################################################
-->
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <NuGetPackageImportStamp>2aa76a0e</NuGetPackageImportStamp>
    <PlatformToolset>CTP_Nov2013</PlatformToolset>
    <ProjectGuid>{4A1D71D5-3DEE-47F0-A189-21C301E2808F}</ProjectGuid>
    <ProjectName>libsx</ProjectName>
  </PropertyGroup>
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="DebugDLL|Win32">
      <Configuration>DebugDLL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseDLL|Win32">
      <Configuration>ReleaseDLL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugDLL|x64">
      <Configuration>DebugDLL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseDLL|x64">
      <Configuration>ReleaseDLL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLTCG|Win32">
      <Configuration>DebugLTCG</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLTCG|Win32">
      <Configuration>ReleaseLTCG</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLTCG|x64">
      <Configuration>DebugLTCG</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLTCG|x64">
      <Configuration>ReleaseLTCG</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLIB|Win32">
      <Configuration>DebugLIB</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLIB|Win32">
      <Configuration>ReleaseLIB</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="DebugLIB|x64">
      <Configuration>DebugLIB</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseLIB|x64">
      <Configuration>ReleaseLIB</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType Condition="$\(Configuration.IndexOf('DLL')) == -1">StaticLibrary</ConfigurationType>
    <ConfigurationType Condition="$\(Configuration.IndexOf('DLL')) != -1">DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <Import Project="$\(VCTargetsPath)\\Microsoft.Cpp.Default.props" />
  <Import Project="$\(VCTargetsPath)\\Microsoft.Cpp.props" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$\(ProjectDir)..\\..\\properties\\$\(Configuration).props" />
    <Import Project="$\(ProjectDir)..\\..\\properties\\Output.props" />
    <Import Project="$\(ProjectDir)$\(ProjectName).props" />
  </ImportGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\sx.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\dispatch.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\display.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\generated.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\obelisk.hpp">
      <ExcludedFromBuild Condition="'$\(Option-obelisk)' != 'true'">true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\coin.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\compat.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\config.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\console.hpp" />
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\environment.hpp" />
  </ItemGroup>
  <ItemGroup>
.for command by symbol
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command\\$(symbol:).hpp" />
.endfor
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\\..\\..\\..\\src\\dispatch.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\display.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\generated.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\obelisk.cpp">
      <ExcludedFromBuild Condition="'$\(Option-obelisk)' != 'true'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\coin.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\config.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\console.cpp" />
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\environment.cpp" />
  </ItemGroup>  
  <ItemGroup>
.for command by symbol
.   if (!is_true(leveldb) & !is_true(obelisk))
    <ClCompile Include="..\\..\\..\\..\\src\\$(symbol:).cpp" />
.   else
    <ClCompile Include="..\\..\\..\\..\\src\\$(symbol:).cpp">
.       if (is_true(leveldb))
      <ExcludedFromBuild Condition="'$\(Option-leveldb)' != 'true'">true</ExcludedFromBuild>
.       endif
.       if (is_true(obelisk))
      <ExcludedFromBuild Condition="'$\(Option-obelisk)' != 'true'">true</ExcludedFromBuild>
.       endif
    </ClCompile>
.   endif
.endfor
  </ItemGroup>
  <Import Project="$\(VCTargetsPath)\\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\LevelDB.1.16.0.5\\build\\native\\LevelDB.props" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\LevelDB.1.16.0.5\\build\\native\\LevelDB.props')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\Snappy.1.1.1.7\\build\\native\\Snappy.props" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\Snappy.1.1.1.7\\build\\native\\Snappy.props')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\Crc32C.1.0.4\\build\\native\\Crc32C.props" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\Crc32C.1.0.4\\build\\native\\Crc32C.props')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost.1.55.0.16\\build\\native\\boost.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost.1.55.0.16\\build\\native\\boost.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.55.0.16\\build\\native\\boost_filesystem.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.55.0.16\\build\\native\\boost_filesystem.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.5.0.0\\build\\native\\libsodium_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.5.0.0\\build\\native\\libsodium_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.703\\build\\native\\openssl_no-asm_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.703\\build\\native\\openssl_no-asm_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_date_time-vc120.1.55.0.16\\build\\native\\boost_date_time-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_date_time-vc120.1.55.0.16\\build\\native\\boost_date_time-vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.55.0.16\\build\\native\\boost_regex-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.55.0.16\\build\\native\\boost_regex-vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.55.0.16\\build\\native\\boost_system-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.55.0.16\\build\\native\\boost_system-vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\pdcurses_vc120.3.4.0.3\\build\\native\\pdcurses_vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\pdcurses_vc120.3.4.0.3\\build\\native\\pdcurses_vc120.targets')" />
    <Import Project="..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.55.0.16\\build\\native\\boost_program_options-vc120.targets" Condition="Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.55.0.16\\build\\native\\boost_program_options-vc120.targets')" />
  </ImportGroup>
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost.1.55.0.16\\build\\native\\boost.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost.1.55.0.16\\build\\native\\boost.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.55.0.16\\build\\native\\boost_filesystem.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_filesystem.1.55.0.16\\build\\native\\boost_filesystem.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\libzmq_vc120.4.1.0.4\\build\\native\\libzmq_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\czmq_vc120.2.2.0.7\\build\\native\\czmq_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\czmqpp_vc120.1.0.0.7\\build\\native\\czmqpp_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.5.0.0\\build\\native\\libsodium_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\libsodium_vc120.0.5.0.0\\build\\native\\libsodium_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\libgmp_vc120.5.1.3.2\\build\\native\\libgmp_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\secp256k1_gmp_vc120.0.1.0.1\\build\\native\\secp256k1_gmp_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.703\\build\\native\\openssl_no-asm_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\openssl_no-asm_vc120.1.0.1.703\\build\\native\\openssl_no-asm_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_date_time-vc120.1.55.0.16\\build\\native\\boost_date_time-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_date_time-vc120.1.55.0.16\\build\\native\\boost_date_time-vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.55.0.16\\build\\native\\boost_regex-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_regex-vc120.1.55.0.16\\build\\native\\boost_regex-vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.55.0.16\\build\\native\\boost_system-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_system-vc120.1.55.0.16\\build\\native\\boost_system-vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\pdcurses_vc120.3.4.0.3\\build\\native\\pdcurses_vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\pdcurses_vc120.3.4.0.3\\build\\native\\pdcurses_vc120.targets'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\Crc32C.1.0.4\\build\\native\\Crc32C.props')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\Crc32C.1.0.4\\build\\native\\Crc32C.props'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\Snappy.1.1.1.7\\build\\native\\Snappy.props')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\Snappy.1.1.1.7\\build\\native\\Snappy.props'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\LevelDB.1.16.0.5\\build\\native\\LevelDB.props')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\LevelDB.1.16.0.5\\build\\native\\LevelDB.props'))" />
    <Error Condition="!Exists('..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.55.0.16\\build\\native\\boost_program_options-vc120.targets')" Text="$\([System.String]::Format('$\(ErrorText)', '..\\..\\..\\..\\..\\..\\nuget\\boost_program_options-vc120.1.55.0.16\\build\\native\\boost_program_options-vc120.targets'))" />
  </Target>
</Project>
.##############################################################################
.echo "Generating builds/msvc/vs2013/libsx/libsx.vcxproj.filter..."
.output "../builds/msvc/vs2013/libsx/libsx.vcxproj.filters"
<?xml version="1.0" encoding="utf-8"?>
<!--
#################################################################
#   GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY    #
#################################################################
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="include\\command">
      <UniqueIdentifier>{8f3f62c0-53c7-4044-a1da-c3fcc9d27651}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\\utility">
      <UniqueIdentifier>{dc28e2c9-d07d-4242-8007-e44440c133a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="include">
      <UniqueIdentifier>{f75d4585-8ee2-45e8-96ec-880c63fc243e}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\command\\obelisk">
      <UniqueIdentifier>{4085fba5-b358-4b3f-968f-ee8be943775f}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\command\\stub">
      <UniqueIdentifier>{e96f4bef-2d18-4897-9078-a8c17783ee65}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\command">
      <UniqueIdentifier>{4085fba5-b358-4b3f-968f-ee8be943775f}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\\utility">
      <UniqueIdentifier>{c50b43cf-9009-45a6-b813-7a61877602f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="src">
      <UniqueIdentifier>{6afc4dd0-6330-4dca-b176-cd4887f27b9f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
.for command by symbol
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command\\$(symbol:).hpp">
      <Filter>include\\command</Filter>
    </ClInclude>
.endfor
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\compat.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\config.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\console.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\environment.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\utility\\coin.hpp">
      <Filter>include\\utility</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\command.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\dispatch.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\display.hpp">
      <Filter>include</Filter>
    </ClInclude>    
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\generated.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\obelisk.hpp">
      <Filter>include</Filter>
    </ClInclude>
    <ClInclude Include="..\\..\\..\\..\\include\\sx\\sx.hpp">
      <Filter>include</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
.for command by symbol
    <ClCompile Include="..\\..\\..\\..\\src\\$(symbol:).cpp">
.   if (is_true(obelisk))
      <Filter>src\\command\\obelisk</Filter>
.   elsif (is_true(stub))
      <Filter>src\\command\\stub</Filter>
.   else
      <Filter>src\\command</Filter>
.   endif
    </ClCompile>
.endfor
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\coin.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\config.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\console.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\utility\\environment.cpp">
      <Filter>src\\utility</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\dispatch.cpp">
      <Filter>src</Filter>
    </ClCompile>    
    <ClCompile Include="..\\..\\..\\..\\src\\display.cpp">
      <Filter>src</Filter>
    </ClCompile>    
    <ClCompile Include="..\\..\\..\\..\\src\\generated.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\\..\\..\\..\\src\\obelisk.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
.##############################################################################